# Visualise
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
from matplotlib.markers import MarkerStyle
from netgraph import Graph
import seaborn as sns
import multimodal_mazes

plt.style.use("../multimodal_mazes/plotting/style_sheet.mplstyle")

"""
Ideas:
    Multiple paths (repeats or different mazes) could be shown as subplots
        with no axis or maze structure. E.g. for the track maze you could plot
        agents x mazes (half left and half right).
"""


def plot_fitness_over_generations(x, plot_species=True):
    """
    Plots max fitness over generations for either all or each species.
    Arguments:
        x: a structured numpy array with generation, species and fitness fields.
            plot_species: True or False.
    Plots:
        max fitness over generations.
            If plot_species=True, species are coloured with increasing alpha.
    """
    plt.subplots()
    # Parameters
    n_generations = int(x["generation"].max())  # counts from 0

    if plot_species:
        n_species = int(x["species"].max())  # counts from 1
        species_alphas = np.linspace(start=0.1, stop=1.0, num=n_species)

        # Max fitness per species
        for s in range(1, n_species + 1):  # for each species
            max_fitness = []
            for g in range(n_generations + 1):
                try:
                    max_fitness.append(
                        x["fitness"][(x["generation"] == g) & (x["species"] == s)].max()
                    )
                except:
                    max_fitness.append(np.nan)
            plt.plot(max_fitness, c="k", alpha=species_alphas[s - 1])
    else:
        # Max fitness over generations
        plt.plot(
            [
                x["fitness"][x["generation"] == g].max()
                for g in range(n_generations + 1)
            ],
            color="k",
        )

    plt.ylim([0.0, 1])
    plt.xlabel("Generation")
    plt.ylabel("Fitness")


def plot_path(path, mz, mz_goal_loc, n_steps):
    """
    Plots an agents path through a single maze.
    Arguments:
        path: a list with the agent's location at each time step [r,c] - generated by maze_trial.
            Pass an empty list to just plot the maze.
        mz: a np array of size x size x channels + 1.
            Where [:,:,-1] stores the maze structure.
        mz_goal_loc: the location of the goal [r,c].
        n_steps: the number of simulation steps.
    Plots:
        The maze structure as path (white) and walls (grey).
        Green circles mark the start (unfilled) and end (filled) locations.
        The agents path with time represented by color.
    """
    plt.subplots()
    path = np.array(path, dtype="double")

    # Draw maze
    plt.imshow(1 - mz[:, :, -1], cmap="binary", alpha=0.25)
    fill_style = ["left", "right"]
    for ch in [0, 1]:
        r, c = np.where(mz[:, :, ch])
        v = mz[:, :, ch][mz[:, :, ch] > 0]

        try:
            plt.scatter(
                x=c,
                y=r,
                s=200,
                alpha=v,
                color="black",
                marker=MarkerStyle("o", fillstyle=fill_style[ch]),
            )
        except:  # for when there are no sensory cues
            pass

    if len(path) > 0:

        # Start and end points
        plt.scatter(
            x=path[0][1],
            y=path[0][0],
            s=400,
            alpha=0.5,
            color="None",
            edgecolors="g",
            linewidths=3,
        )  # start
        plt.scatter(
            x=mz_goal_loc[1],
            y=mz_goal_loc[0],
            s=400,
            alpha=0.5,
            color="g",
            linewidths=3.0,
        )  # end

        # Add jitter to path (except start and end points)
        path[1:-1, :] = path[1:-1, :] + np.random.uniform(
            -0.25, 0.25, (len(path) - 2, 2)
        )

        # Plot path
        cmap = colors.LinearSegmentedColormap.from_list(
            "", ["xkcd:teal blue", "xkcd:off white", "xkcd:coral"], N=n_steps
        )
        for t in range(len(path) - 1):
            plt.plot(
                [path[t, 1], path[t + 1, 1]], [path[t, 0], path[t + 1, 0]], c=cmap(t)
            )
            plt.scatter(path[t + 1, 1], path[t + 1, 0], s=30, color=cmap(t))

    plt.axis("off")


def plot_architecture(genome, config, node_names):
    """
    Plots the network architecture.
    Arguments:
        genome: neat generated genome.
        config: the neat configuration holder.
        node_names: a dictionary with value:name pairs for
            each input and output node.
    Plots:
        The architecture with labelled input and output nodes.
        Edges are directed, and coloured by their weight.
    Note: For help with Graph see line 1166
        https://github.com/paulbrodersen/netgraph/blob/master/netgraph/_main.py
    """
    # Edges
    edges = []  # (source, target, weight)
    for cg in genome.connections.values():
        if cg.enabled:
            source, target = cg.key
            edges.append((source, target, cg.weight))

    # Nodes
    nodes = np.unique(np.array(edges)[:, :2])
    node_positions = {}  # node : (x, y)

    # Input nodes
    for k in config.genome_config.input_keys:
        node_positions.update({k: (0.0, abs(k) * 0.1)})

    # Hidden nodes
    center = (len(config.genome_config.input_keys) + 1) / 2
    h_nodes, layers = multimodal_mazes.define_layers(genome, config)
    if len(layers) > 0:
        for layer in np.unique(layers):
            n_nodes_l = sum(layers == layer)
            pos = np.linspace(
                start=center - n_nodes_l / 2, stop=center + n_nodes_l / 2, num=n_nodes_l
            )

            if n_nodes_l == 1:
                pos += 0.5

            for a, k in enumerate(h_nodes[layers == layer]):
                node_positions.update({k: (layer * 0.2, pos[a] * 0.1)})
    else:
        layers = [0]

    # Output nodes
    for k in config.genome_config.output_keys:
        node_positions.update({k: ((max(layers) + 1) * 0.2, abs(k) * 0.1 + 0.3)})

    # Plotting
    cmap = "PiYG"
    Graph(
        edges,
        node_layout=node_positions,
        node_size=3,
        edge_cmap=cmap,
        edge_width=1.0,
        arrows=True,
    )

    # Labels
    # Input nodes
    for k in config.genome_config.input_keys:
        if np.isin(k, nodes):
            plt.text(-0.2, (abs(k) * 0.1) - 0.02, node_names[k], fontsize=15.0)

    # Output nodes
    for k in config.genome_config.output_keys:
        if np.isin(k, nodes):
            plt.text(
                (max(layers) + 1) * 0.2 + 0.05,
                (abs(k) * 0.1) + 0.3 - 0.02,
                node_names[k],
                fontsize=15.0,
            )


def plot_robustness(
    condition_values,
    condition_results,
    condition_label,
    noise_baseline,
    agents,
    genomes,
    config,
    node_names,
):
    """
    Plots robustness to a condition (e.g. sensor noise vs fitness),
        and the least and most robust architectures.
    Arguments:
        condition_values: a np vector of condition values.
        condition_results: a np array with each agents fitness per condition value.
        condition_label: a string to label subplot 0.
        noise_baseline: as condition_results, but using random agents.
        agents: a list of indicies, of the genomes to test.
        genomes: neat generated genomes.
        config: the neat configuration holder.
        node_names: a dictionary with value:name pairs for
            each input and output node.
    Plots: three subplots
        0: condition vs fitness + a noise floor. Highlights the most and least robust networks.
        1: the architecture of the least robust network.
        2: the architecture of the most robust network.
    """

    labels = ["Least robust", "Most robust"]
    col = ["xkcd:purple", "xkcd:dark seafoam"]
    _, ax = plt.subplots(
        1, 3, gridspec_kw={"width_ratios": [0.4, 0.3, 0.3]}, figsize=(15, 5)
    )

    plt.sca(ax[0])
    # Plot condition vs fitness
    plt.plot(condition_values, condition_results.T, c="k", alpha=0.1)

    # Plot condition vs noise baseline
    plt.plot(
        condition_values, np.mean(noise_baseline, axis=0), c="xkcd:gray", ls="dotted"
    )
    plt.fill_between(
        condition_values,
        np.min(noise_baseline, axis=0),
        np.max(noise_baseline, axis=0),
        color="xkcd:gray",
        alpha=0.25,
    )

    plt.ylim(0, 1.0)
    plt.title(condition_label)
    plt.ylabel("Fitness")

    # Least and most robust networks
    condition_results_min = np.argmin(np.trapz(y=condition_results, x=condition_values))
    condition_results_max = np.argmax(np.trapz(y=condition_results, x=condition_values))

    for a, n in enumerate([condition_results_min, condition_results_max]):
        # Condition vs fitness
        plt.sca(ax[0])
        plt.plot(condition_values, condition_results[n], c=col[a], alpha=0.75)

        # Architecture
        plt.sca(ax[a + 1])
        plt.title(labels[a])
        _, genome, _ = genomes[agents[n]]
        genome = multimodal_mazes.prune_architecture(genome, config)
        multimodal_mazes.plot_architecture(genome, config, node_names=node_names)
        plt.ylim([0.05, 0.85])


def unique_legend(ax, order, loc):
    """
    Adds a legend with only unique labels to a plot.
    Arguments:
        ax: the matplotlib axis to plot on.
        order: a list with the desired legend order.
        loc: a string specifying where to place the legend.
    """
    handles, labels = ax.get_legend_handles_labels()
    unique = [
        (h, l) for i, (h, l) in enumerate(zip(handles, labels)) if l not in labels[:i]
    ]
    if order is not None:
        unique = [unique[i] for i in order]
    ax.legend(*zip(*unique), frameon=False, loc=loc)


def plot_dqn_architecture(wm_flag, ax=None, color=None):
    """
    Plots a dqn architecture.
    Arguments:
        wm_flag: a 7 element binary vector, which includes or excludes each additional weight matrix.
        ax: a matplotlib axis (only needed if a color is provided)
        color: when provided, the whole architecture will be drawn with one color.
    """
    # F0 and F1
    plt.scatter(x=[0, 1, 2], y=[1, 1, 1], color="xkcd:slate grey", zorder=1)
    plt.plot([0, 2], [1, 1], color="xkcd:slate grey", zorder=1)
    plt.arrow(
        0.35, 1, dx=0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:slate grey"
    )
    plt.arrow(
        1.35, 1, dx=0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:slate grey"
    )

    # L0, L1, L2
    for l in range(3):
        if wm_flag[l]:
            plt.plot([l, l], [0.75, 1.25], color="xkcd:teal blue", zorder=0)
            plt.arrow(
                l,
                0.9,
                dx=0.0,
                dy=-0.1,
                width=0.0,
                head_width=0.1,
                color="xkcd:teal blue",
            )
            plt.arrow(
                l,
                1.1,
                dx=0.0,
                dy=0.1,
                width=0.0,
                head_width=0.1,
                color="xkcd:teal blue",
            )

    if wm_flag[3]:  # S0
        plt.plot([0.1, 1.9], [1.5, 1.5], color="xkcd:topaz", zorder=0)
        plt.arrow(
            0.85, 1.5, dx=0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:topaz"
        )

    if wm_flag[4]:  # S1
        plt.plot([0.1, 1.9], [0.5, 0.5], color="xkcd:topaz", zorder=0)
        plt.arrow(
            1.15, 0.5, dx=-0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:topaz"
        )

    if wm_flag[5]:  # B0
        plt.plot([0.1, 0.9], [1.25, 1.25], color="xkcd:orange", zorder=0)
        plt.arrow(
            0.67, 1.25, dx=-0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:orange"
        )

    if wm_flag[6]:  # B1
        plt.plot([1.1, 1.9], [0.75, 0.75], color="xkcd:orange", zorder=0)
        plt.arrow(
            1.67, 0.75, dx=-0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:orange"
        )

    plt.ylim([0.25, 1.75])
    plt.axis("off")

    if color:
        for line in ax.get_lines():
            line.set_color(color)

        for patch in ax.patches:
            patch.set_facecolor(color)
            patch.set_edgecolor(color)

        for path_collection in ax.collections:
            path_collection.set_facecolor(color)
            path_collection.set_edgecolor(color)


def plot_dqn_weight_matrix(n_input_units, n_hidden_units, n_output_units, wm_flag):
    """ """
    cmap = colors.ListedColormap(
        ["white", "xkcd:slate grey", "xkcd:teal blue", "xkcd:topaz", "xkcd:orange"]
    )

    ni = n_input_units
    nh = n_input_units + n_hidden_units
    no = n_input_units + n_hidden_units + n_output_units

    w = np.zeros((no, no))

    w[:ni, ni:nh] = 1  # ih
    w[ni:nh, nh:no] = 1  # ho

    if wm_flag[0]:  # ii
        w[:ni, :ni] = 2
    if wm_flag[1]:  # hh
        w[ni:nh, ni:nh] = 2
    if wm_flag[2]:  ## oo
        w[nh:, nh:] = 2
    if wm_flag[3]:  # io
        w[:ni, nh:] = 3
    if wm_flag[4]:  # oi
        w[nh:, :ni] = 3
    if wm_flag[5]:  # hi
        w[ni:nh, :ni] = 4
    if wm_flag[6]:  # oh
        w[nh:, ni:nh] = 4

    plt.imshow(w, cmap=cmap, vmin=0, vmax=4)


def plot_dqn_rankings(y, y_label, interest, i_cols, y_lim=None, sig_test=False):
    """
    Plot each architecture's distribution for a given metric.
        Sorted by their median value.
    Arguments:
        y: metric - architectures x repeats.
        y_label: y axis label.
        interest: a list of architectures to highlight.
        i_cols: a list of colors for each architecture of interest.
        y_lim: y axis limits.
        sig_test: if an architecture label (an int) is provided.
            Test for significant differences between label and all other architectures.
            Uses Mann-Whitney U, with correction for multiple comparions.
    """

    idxs = np.argsort(np.nanmedian(y, axis=1))

    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(30, 5), sharex=True, sharey=True)

    # All networks
    l, m, u = np.nanquantile(y, [0.25, 0.5, 0.75], axis=1)
    plt.scatter(range(y.shape[0]), m[idxs], c="xkcd:grey")
    plt.plot([range(y.shape[0]), range(y.shape[0])], [l[idxs], u[idxs]], c="xkcd:grey")

    # Interest
    for a, i in enumerate(interest):
        plt.scatter(np.where(idxs == i)[0], m[i], c=i_cols[a])
        plt.plot(
            [np.where(idxs == i)[0], np.where(idxs == i)[0]], [l[i], u[i]], c=i_cols[a]
        )

    ax.set_xticks([])
    ax.spines["bottom"].set_visible(False)
    plt.xlim(-1, y.shape[0])
    if y_lim:
        plt.ylim(y_lim)
    plt.ylabel(y_label)

    # Significance testing
    if sig_test:
        from scipy import stats

        ps = []
        for a, i in enumerate(idxs):
            _, p = stats.mannwhitneyu(
                x=y[sig_test], y=y[i], method="asymptotic", nan_policy="omit"
            )
            ps.append(p)

        # Multiple comparions adjustment
        ps = np.array(ps)
        ps = stats.false_discovery_control(ps)
        print(str(np.sum(ps < 0.01)) + " significantly different")

        for a, i in enumerate(idxs):
            if ps[a] < 0.01:
                plt.scatter(
                    x=a,
                    y=np.nanmedian(y[idxs[-1]]) * 1.05,
                    c=i_cols[np.where(np.array(interest) == sig_test)[0][0]],
                    marker="$*$",
                )


def plot_dqn_examples(y, y_label, interest, i_cols, y_lim=None, sig_test=False):
    """
    Plot the overall distribution for a given metric,
        And the distributions for the architectures in interest.
    Arguments:
        y: metric - architectures x repeats.
        y_label: y axis label.
        interest: a list of architectures to highlight.
        i_cols: a list of colors for the interest architectures.
        y_lim: y axis limits.
        sig_test: if an architecture label (an int) is provided.
            Test for significant differences between label and the architectures in interest.
            Uses Mann-Whitney U.
    """

    import warnings

    warnings.filterwarnings("ignore", module="seaborn")

    fig, ax = plt.subplots(
        nrows=1, ncols=len(interest) + 1, figsize=(5, 5), sharex=False, sharey=True
    )

    # Overall distribution
    plt.sca(ax[0])
    sns.violinplot(y.reshape(-1), color="w", linewidth=3, inner=None, cut=0)
    ax[0].set_xticks([])
    ax[0].spines["bottom"].set_visible(False)
    plt.ylabel(y_label)
    if y_lim:
        plt.ylim(y_lim)

    # Architectures of interest
    for a, i in enumerate(interest):
        plt.sca(ax[a + 1])
        sns.swarmplot(y[i], color=i_cols[a])
        plt.axis("off")

    # Significance testing
    if sig_test:
        from scipy.stats import mannwhitneyu

        for a, i in enumerate(interest):
            _, p = mannwhitneyu(
                x=y[sig_test], y=y[i], method="asymptotic", nan_policy="omit"
            )
            if p < 0.01:
                plt.sca(ax[a + 1])
                plt.scatter(
                    x=0,
                    y=max(y.reshape(-1)) + (0.1 * max(y.reshape(-1))),
                    c=i_cols[np.where(np.array(interest) == sig_test)[0][0]],
                    marker="$*$",
                )


def plot_cf_effects(ce, f0, f1, y, cols, x_labels, y_label):
    """
    Plots all counterfactual effects (per feature).
        Highlighting significant effects.
    Arguments:
        ce: counterfactual effects for each feature (ce pairs, features).
        f0: indicies without each feature (ce pairs, features).
        f1: indicies with each feature (ce pairs, features).
        y: metric (architectures, repeats)
        cols: a list of colors (one per feature).
        x_labels: a list of labels (one per feature).
        y_label: a label for the y-axis (str).
    """

    from scipy import stats
    import warnings

    warnings.filterwarnings("ignore", module="seaborn")

    # Significance testing
    ps = np.zeros_like(ce) * np.nan
    for a in range(ce.shape[0]):
        for b in range(ce.shape[1]):

            _, p = stats.mannwhitneyu(
                x=y[f0[a, b]], y=y[f1[a, b]], method="asymptotic", nan_policy="omit"
            )

            ps[a, b] = p

    ps = stats.false_discovery_control(ps)
    ps = (ps < 0.01) * 1  # binary (ce pairs, features)

    # Plotting
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(5 * 2, 5))

    palettes = []
    for a, c in enumerate(cols):
        if np.sum(ps[:, a]) == 0:
            palettes.append(["xkcd:light grey"])
        elif np.sum(ps[:, a]) == ps.shape[0]:
            palettes.append([c])
        else:
            palettes.append(["xkcd:light grey", c])

    plt.hlines(y=0.0, xmin=-0.5, xmax=ce.shape[1] - 0.5, color="xkcd:grey", zorder=0)

    l, m, u = np.nanquantile(ce, [0.25, 0.5, 0.75], axis=0)
    idx_f = np.argsort(m)

    for a, i in enumerate(idx_f):
        sns.swarmplot(
            x=np.ones(ce.shape[0]) * a,
            y=ce[:, i],
            hue=ps[:, i],
            palette=palettes[i],
            zorder=1,
        )

    plt.xlabel("Weight matrix")
    plt.xticks(range(len(x_labels)), [x_labels[i] for i in idx_f])
    plt.ylabel("Ce of $W$ on " + y_label)
    l_overall, m_overall, u_overall = np.nanquantile(ce, [0.05, 0.5, 0.95])
    plt.ylim(l_overall * 2, u_overall * 2)
    plt.legend([], [], frameon=False)


def plot_cf_max(ce, f0, f1, y, wm_flags, y_label, p_metric, exclude_architectures=[]):
    """
    Plot the maximum counterfactual effect for a given metric (y):
        Two architectures and their distribtuions across repeats.
    Arguments:
        ce: counterfactual effects for each feature (ce pairs, features).
        f0: indicies without each feature (ce pairs, features).
        f1: indicies with each feature (ce pairs, features).
        y: metric (architectures x repeats)
        wm_flags: a binary matrix (architectures x features x repeats)
        y_label: a label for the y-axis (str).
        p_metric: the metric to be used for plotting (shape depends on y label).
        exclude_architectures: provide a list of ints to exclude specific architectures.
    Note:
        Currently makes quite strong assumptions for plotting.
    """
    from scipy import stats

    # Find most extreme counterfactual pair
    ce = ce.reshape(-1)
    f0 = f0.reshape(-1)
    f1 = f1.reshape(-1)

    if len(exclude_architectures) > 0:
        for i in exclude_architectures:
            ce[f0 == i] = np.nan
            ce[f1 == i] = np.nan

    idx_m = np.nanargmax(abs(ce))
    interest = [f0[idx_m], f1[idx_m]]
    i_cols = ["xkcd:grey", "xkcd:dark seafoam green"]

    # Plotting
    fig, ax = plt.subplot_mosaic([["ul", "ur"], ["l", "l"]], figsize=(5, 5))

    # Architectures
    plt.sca(ax["ul"])
    multimodal_mazes.plot_dqn_architecture(
        np.nanmax(wm_flags, axis=2)[interest[0]], ax=ax["ul"], color=i_cols[0]
    )

    plt.sca(ax["ur"])
    ax["ur"].sharex(ax["ul"])
    ax["ur"].sharey(ax["ul"])
    multimodal_mazes.plot_dqn_architecture(
        np.nanmax(wm_flags, axis=2)[interest[1]],
        ax=ax["ur"],
        color=i_cols[1],
    )

    # Metric
    plt.sca(ax["l"])

    if y_label == "Fitness":
        sns.swarmplot(x=0, y=y[interest[0]], c=i_cols[0])
        sns.swarmplot(x=1, y=y[interest[1]], c=i_cols[1])
        plt.xticks([])
        plt.xlim([-0.5, 1.5])
        plt.ylabel(y_label)

        # Statistical comparison
        _, p = stats.mannwhitneyu(
            x=y[interest[0]], y=y[interest[1]], method="asymptotic", nan_policy="omit"
        )

        if p < 0.01:
            plt.scatter(
                x=1,
                y=max(y[interest[1]]) * 1.05,
                c="k",
                marker="$*$",
            )

    elif y_label == "SE":
        for a, i in enumerate(interest):
            x = range(p_metric.shape[1])
            l, m, u = np.nanquantile(p_metric[i], [0.25, 0.5, 0.75], axis=1)
            plt.plot(x, m, color=i_cols[a])
            plt.fill_between(x, l, u, color=i_cols[a], alpha=0.25, edgecolor=None)

        plt.xticks([0, 49, 99], labels=["0", "50", "100"])
        plt.xlabel("Percentage of training")
        plt.ylabel("Fitness")

    elif y_label == "Robustness":

        # Interest
        for a, i in enumerate(interest):
            x = np.linspace(start=0.0, stop=0.5, num=21)
            l, m, u = np.nanquantile(p_metric[:, i], [0.25, 0.5, 0.75], axis=1)
            plt.plot(x, m, color=i_cols[a])
            plt.fill_between(x, l, u, color=i_cols[a], alpha=0.25, edgecolor=None)

        plt.plot(
            [0.05, 0.05], [0, 1], ":", color="k", alpha=0.5, label="Training noise"
        )

        # Fitness vs noise
        plt.ylabel("Fitness")
        plt.xlabel("Sensor noise")
        plt.legend()

    elif y_label == "IS":
        for a, arch in enumerate(interest):
            y_means_arch = []
            for b in range(len(p_metric[arch])):

                xs = p_metric[arch][b][2][0]
                ys = p_metric[arch][b][2][1]

                bins = np.linspace(start=-1, stop=1, num=22)
                bin_idxs = np.digitize(xs, bins) - 1
                bin_centers = (bins[:-1] + bins[1:]) / 2

                y_means = [np.mean(ys[bin_idxs == i]) for i in range(len(bins) - 1)]
                y_means_arch.append(y_means)

            l, m, u = np.nanquantile(np.array(y_means_arch), [0.25, 0.5, 0.75], axis=0)
            plt.fill_between(
                bin_centers, l, u, color=i_cols[a], alpha=0.25, edgecolor=None
            )
            plt.plot(bin_centers, m, color=i_cols[a])

        plt.xticks(ticks=[-1, 0, 1], labels=("-1.0", "0.0", "1.0"))
        plt.xlabel("Input state (L:R)")
        plt.ylabel("Input sensitivity")
        plt.legend()

    elif y_label == "Memory":
        for a, i in enumerate(interest):
            x = range(p_metric[i, 2].shape[0])
            l, m, u = np.nanquantile(p_metric[i, 2], [0.25, 0.5, 0.75], axis=1)
            plt.plot(x, m[::-1], color=i_cols[a])
            plt.fill_between(
                x, l[::-1], u[::-1], color=i_cols[a], alpha=0.25, edgecolor=None
            )

        plt.hlines(
            y=1.0, xmin=0, xmax=p_metric.shape[2] - 1, color="k", linestyles="--"
        )
        plt.ylabel("Memory")
        plt.xlabel("Time")
        plt.xticks([0, len(m) - 1], [-len(m) + 1, 0])
