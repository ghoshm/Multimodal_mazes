# Visualise
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
from netgraph import Graph

plt.style.use("../multimodal_mazes/plotting/style_sheet.mplstyle")


def plot_fitness_over_generations(x, plot_species=True):
    """
    Plots max fitness over generations for either all or each species.
    Arguments:
        x: a structured numpy array with generation, species and fitness fields.
            plot_species: True or False.
    Plots:
        max fitness over generations.
            If plot_species=True, species are coloured with increasing alpha.
    """
    plt.subplots()
    # Parameters
    n_generations = int(x["generation"].max())  # counts from 0

    if plot_species:
        n_species = int(x["species"].max())  # counts from 1
        species_alphas = np.linspace(start=0.1, stop=1.0, num=n_species)

        # Max fitness per species
        for s in range(1, n_species + 1):  # for each species
            max_fitness = []
            for g in range(n_generations + 1):
                try:
                    max_fitness.append(
                        x["fitness"][(x["generation"] == g) & (x["species"] == s)].max()
                    )
                except:
                    max_fitness.append(np.nan)
            plt.plot(max_fitness, c="k", alpha=species_alphas[s - 1])
    else:
        # Max fitness over generations
        plt.plot(
            [
                x["fitness"][x["generation"] == g].max()
                for g in range(n_generations + 1)
            ],
            color="k",
        )

    plt.ylim([0.5, 1])
    plt.xlabel("Generation")
    plt.ylabel("Fitness")


def plot_path(path, mz, mz_goal_loc, n_steps):
    """
    Plots an agents path through a single maze.
    Arguments:
        path: a list with the agent's location at each time step [x,y] - generated by maze_trial.
        mz: a np array of size x size x channels + 1.
            Where [:,:,-1] stores the maze structure.
        mz_goal_loc: the location of the goal [x].
        n_steps: the number of simulation steps.
    Plots:
        The maze structure as path (white) and walls (grey).
        The start and end locations as grey and green circles.
        The agents path with time represented by color.
    """
    path = np.array(path, dtype="double")

    # Draw maze
    plt.imshow(mz[:, :, -1], cmap="binary", alpha=0.25)

    # Start and end points
    plt.scatter(
        path[0, 1], path[0, 0], s=400, color="k", linewidths=0.0, alpha=0.25
    )  # start
    plt.scatter(mz_goal_loc, 5, s=400, color="g", linewidths=0.0, alpha=0.25)  # end

    # Add jitter to path (except start and end points)
    path[1:-1, 0] = path[1:-1, 0] + (np.random.rand(len(path) - 2) / 3)

    # Plot path
    cmap = colors.LinearSegmentedColormap.from_list(
        "", ["xkcd:teal blue", "xkcd:off white", "xkcd:coral"], N=n_steps
    )
    for t in range(len(path) - 1):
        plt.plot([path[t, 1], path[t + 1, 1]], [path[t, 0], path[t + 1, 0]], c=cmap(t))
        plt.scatter(path[t + 1, 1], path[t + 1, 0], color=cmap(t))

    plt.axis("off")


def plot_architecture(genome, config, node_names):
    """
    Plots the network architecture.
    Arguments:
        genome: neat generated genome.
        config: the neat configuration holder.
        node_names: a dictionary with value:name pairs for
            each input and output node.
    Plots:
        The architecture with labelled input and output nodes.
        Edges are directed, and coloured by their weight.
    Note: For help with Graph see line 1166
        https://github.com/paulbrodersen/netgraph/blob/master/netgraph/_main.py
    """
    plt.subplots()
    # Edges
    edges = []  # (source, target, weight)
    for cg in genome.connections.values():
        if cg.enabled:
            source, target = cg.key
            edges.append((source, target, cg.weight))

    # Nodes
    node_positions = {}  # node : (x, y)

    # Input nodes
    for k in config.genome_config.input_keys:
        node_positions.update({k: (0.0, abs(k) * 0.1)})

    # Hidden nodes
    # Note: you could define the number of layers using path lengths
    n_counter = 0.05
    h_layer = 0.2
    offset = (
        len(config.genome_config.input_keys)
        // (len(genome.nodes.keys()) - len(config.genome_config.output_keys) + 1)
        * 0.1
    )
    for k in genome.nodes.keys():
        if k > config.genome_config.output_keys[-1]:
            node_positions.update({k: (h_layer, n_counter + offset)})
            n_counter += 0.1

    if n_counter > 0.05:
        h_layer += 0.2

    # Output nodes
    offset = (
        len(config.genome_config.input_keys) // len(config.genome_config.output_keys)
    ) * 0.1
    for k in config.genome_config.output_keys:
        node_positions.update({k: (h_layer, abs(k) * 0.1 + offset)})

    # Plotting
    cmap = "PiYG"
    Graph(
        edges, node_layout=node_positions, edge_cmap=cmap, edge_width=1.0, arrows=True
    )

    # Labels
    # Input nodes
    for k in config.genome_config.input_keys:
        plt.text(-0.15, (abs(k) * 0.1) - 0.01, node_names[k], fontsize=15.0)

    # Output nodes
    for k in config.genome_config.output_keys:
        plt.text(
            h_layer + 0.05, (abs(k) * 0.1) - 0.01 + offset, node_names[k], fontsize=15.0
        )

    plt.show()
