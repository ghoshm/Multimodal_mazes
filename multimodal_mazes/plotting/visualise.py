# Visualise
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
from matplotlib.markers import MarkerStyle
from netgraph import Graph
import seaborn as sns
import multimodal_mazes

plt.style.use("../multimodal_mazes/plotting/style_sheet.mplstyle")

"""
Ideas:
    Multiple paths (repeats or different mazes) could be shown as subplots
        with no axis or maze structure. E.g. for the track maze you could plot
        agents x mazes (half left and half right).
"""


def plot_fitness_over_generations(x, plot_species=True):
    """
    Plots max fitness over generations for either all or each species.
    Arguments:
        x: a structured numpy array with generation, species and fitness fields.
            plot_species: True or False.
    Plots:
        max fitness over generations.
            If plot_species=True, species are coloured with increasing alpha.
    """
    plt.subplots()
    # Parameters
    n_generations = int(x["generation"].max())  # counts from 0

    if plot_species:
        n_species = int(x["species"].max())  # counts from 1
        species_alphas = np.linspace(start=0.1, stop=1.0, num=n_species)

        # Max fitness per species
        for s in range(1, n_species + 1):  # for each species
            max_fitness = []
            for g in range(n_generations + 1):
                try:
                    max_fitness.append(
                        x["fitness"][(x["generation"] == g) & (x["species"] == s)].max()
                    )
                except:
                    max_fitness.append(np.nan)
            plt.plot(max_fitness, c="k", alpha=species_alphas[s - 1])
    else:
        # Max fitness over generations
        plt.plot(
            [
                x["fitness"][x["generation"] == g].max()
                for g in range(n_generations + 1)
            ],
            color="k",
        )

    plt.ylim([0.0, 1])
    plt.xlabel("Generation")
    plt.ylabel("Fitness")


def plot_path(path, mz, mz_goal_loc, n_steps):
    """
    Plots an agents path through a single maze.
    Arguments:
        path: a list with the agent's location at each time step [r,c] - generated by maze_trial.
        mz: a np array of size x size x channels + 1.
            Where [:,:,-1] stores the maze structure.
        mz_goal_loc: the location of the goal [r,c].
        n_steps: the number of simulation steps.
    Plots:
        The maze structure as path (white) and walls (grey).
        Green circles mark the start (unfilled) and end (filled) locations.
        The agents path with time represented by color.
    """
    plt.subplots()
    path = np.array(path, dtype="double")

    # Draw maze
    plt.imshow(1 - mz[:, :, -1], cmap="binary", alpha=0.25)
    fill_style = ["left", "right"]
    for ch in [0, 1]:
        r, c = np.where(mz[:, :, ch])
        v = mz[:, :, ch][mz[:, :, ch] > 0]

        try:
            plt.scatter(
                x=c,
                y=r,
                s=200,
                alpha=v,
                color="black",
                marker=MarkerStyle("o", fillstyle=fill_style[ch]),
            )
        except:  # for when there are no sensory cues
            pass

    # Start and end points
    plt.scatter(
        x=path[0][1],
        y=path[0][0],
        s=400,
        alpha=0.5,
        color="None",
        edgecolors="g",
        linewidths=3,
    )  # start
    plt.scatter(
        x=mz_goal_loc[1],
        y=mz_goal_loc[0],
        s=400,
        alpha=0.5,
        color="g",
        linewidths=3.0,
    )  # end

    # Add jitter to path (except start and end points)
    path[1:-1, :] = path[1:-1, :] + np.random.uniform(-0.25, 0.25, (len(path) - 2, 2))

    # Plot path
    cmap = colors.LinearSegmentedColormap.from_list(
        "", ["xkcd:teal blue", "xkcd:off white", "xkcd:coral"], N=n_steps
    )
    for t in range(len(path) - 1):
        plt.plot([path[t, 1], path[t + 1, 1]], [path[t, 0], path[t + 1, 0]], c=cmap(t))
        plt.scatter(path[t + 1, 1], path[t + 1, 0], s=30, color=cmap(t))

    plt.axis("off")


def plot_architecture(genome, config, node_names):
    """
    Plots the network architecture.
    Arguments:
        genome: neat generated genome.
        config: the neat configuration holder.
        node_names: a dictionary with value:name pairs for
            each input and output node.
    Plots:
        The architecture with labelled input and output nodes.
        Edges are directed, and coloured by their weight.
    Note: For help with Graph see line 1166
        https://github.com/paulbrodersen/netgraph/blob/master/netgraph/_main.py
    """
    # Edges
    edges = []  # (source, target, weight)
    for cg in genome.connections.values():
        if cg.enabled:
            source, target = cg.key
            edges.append((source, target, cg.weight))

    # Nodes
    nodes = np.unique(np.array(edges)[:, :2])
    node_positions = {}  # node : (x, y)

    # Input nodes
    for k in config.genome_config.input_keys:
        node_positions.update({k: (0.0, abs(k) * 0.1)})

    # Hidden nodes
    center = (len(config.genome_config.input_keys) + 1) / 2
    h_nodes, layers = multimodal_mazes.define_layers(genome, config)
    if len(layers) > 0:
        for layer in np.unique(layers):
            n_nodes_l = sum(layers == layer)
            pos = np.linspace(
                start=center - n_nodes_l / 2, stop=center + n_nodes_l / 2, num=n_nodes_l
            )

            if n_nodes_l == 1:
                pos += 0.5

            for a, k in enumerate(h_nodes[layers == layer]):
                node_positions.update({k: (layer * 0.2, pos[a] * 0.1)})
    else:
        layers = [0]

    # Output nodes
    for k in config.genome_config.output_keys:
        node_positions.update({k: ((max(layers) + 1) * 0.2, abs(k) * 0.1 + 0.3)})

    # Plotting
    cmap = "PiYG"
    Graph(
        edges,
        node_layout=node_positions,
        node_size=3,
        edge_cmap=cmap,
        edge_width=1.0,
        arrows=True,
    )

    # Labels
    # Input nodes
    for k in config.genome_config.input_keys:
        if np.isin(k, nodes):
            plt.text(-0.2, (abs(k) * 0.1) - 0.02, node_names[k], fontsize=15.0)

    # Output nodes
    for k in config.genome_config.output_keys:
        if np.isin(k, nodes):
            plt.text(
                (max(layers) + 1) * 0.2 + 0.05,
                (abs(k) * 0.1) + 0.3 - 0.02,
                node_names[k],
                fontsize=15.0,
            )


def plot_robustness(
    condition_values,
    condition_results,
    condition_label,
    noise_baseline,
    agents,
    genomes,
    config,
    node_names,
):
    """
    Plots robustness to a condition (e.g. sensor noise vs fitness),
        and the least and most robust architectures.
    Arguments:
        condition_values: a np vector of condition values.
        condition_results: a np array with each agents fitness per condition value.
        condition_label: a string to label subplot 0.
        noise_baseline: as condition_results, but using random agents.
        agents: a list of indicies, of the genomes to test.
        genomes: neat generated genomes.
        config: the neat configuration holder.
        node_names: a dictionary with value:name pairs for
            each input and output node.
    Plots: three subplots
        0: condition vs fitness + a noise floor. Highlights the most and least robust networks.
        1: the architecture of the least robust network.
        2: the architecture of the most robust network.
    """

    labels = ["Least robust", "Most robust"]
    col = ["xkcd:purple", "xkcd:dark seafoam"]
    _, ax = plt.subplots(
        1, 3, gridspec_kw={"width_ratios": [0.4, 0.3, 0.3]}, figsize=(15, 5)
    )

    plt.sca(ax[0])
    # Plot condition vs fitness
    plt.plot(condition_values, condition_results.T, c="k", alpha=0.1)

    # Plot condition vs noise baseline
    plt.plot(
        condition_values, np.mean(noise_baseline, axis=0), c="xkcd:gray", ls="dotted"
    )
    plt.fill_between(
        condition_values,
        np.min(noise_baseline, axis=0),
        np.max(noise_baseline, axis=0),
        color="xkcd:gray",
        alpha=0.25,
    )

    plt.ylim(0, 1.0)
    plt.title(condition_label)
    plt.ylabel("Fitness")

    # Least and most robust networks
    condition_results_min = np.argmin(np.trapz(y=condition_results, x=condition_values))
    condition_results_max = np.argmax(np.trapz(y=condition_results, x=condition_values))

    for a, n in enumerate([condition_results_min, condition_results_max]):
        # Condition vs fitness
        plt.sca(ax[0])
        plt.plot(condition_values, condition_results[n], c=col[a], alpha=0.75)

        # Architecture
        plt.sca(ax[a + 1])
        plt.title(labels[a])
        _, genome, _ = genomes[agents[n]]
        genome = multimodal_mazes.prune_architecture(genome, config)
        multimodal_mazes.plot_architecture(genome, config, node_names=node_names)
        plt.ylim([0.05, 0.85])


def unique_legend(ax, order, loc):
    """
    Adds a legend with only unique labels to a plot.
    Arguments:
        ax: the matplotlib axis to plot on.
        order: a list with the desired legend order.
        loc: a string specifying where to place the legend.
    """
    handles, labels = ax.get_legend_handles_labels()
    unique = [
        (h, l) for i, (h, l) in enumerate(zip(handles, labels)) if l not in labels[:i]
    ]
    if order is not None:
        unique = [unique[i] for i in order]
    ax.legend(*zip(*unique), frameon=False, loc=loc)


def plot_dqn_architecture(wm_flag, ax=None, color=None):
    """
    Plots a dqn architecture.
    Arguments:
        wm_flag: a 7 element binary vector, which includes or excludes each additional weight matrix.
        ax: a matplotlib axis (only needed if a color is provided)
        color: when provided, the whole architecture will be drawn with one color.
    """
    # F0 and F1
    plt.scatter(x=[0, 1, 2], y=[1, 1, 1], color="xkcd:slate grey", zorder=1)
    plt.plot([0, 2], [1, 1], color="xkcd:slate grey", zorder=1)
    plt.arrow(
        0.35, 1, dx=0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:slate grey"
    )
    plt.arrow(
        1.35, 1, dx=0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:slate grey"
    )

    # L0, L1, L2
    for l in range(3):
        if wm_flag[l]:
            plt.plot([l, l], [0.75, 1.25], color="xkcd:teal blue", zorder=0)
            plt.arrow(
                l,
                0.9,
                dx=0.0,
                dy=-0.1,
                width=0.0,
                head_width=0.1,
                color="xkcd:teal blue",
            )
            plt.arrow(
                l,
                1.1,
                dx=0.0,
                dy=0.1,
                width=0.0,
                head_width=0.1,
                color="xkcd:teal blue",
            )

    if wm_flag[3]:  # S0
        plt.plot([0.1, 1.9], [1.5, 1.5], color="xkcd:topaz", zorder=0)
        plt.arrow(
            0.85, 1.5, dx=0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:topaz"
        )

    if wm_flag[4]:  # S1
        plt.plot([0.1, 1.9], [0.5, 0.5], color="xkcd:topaz", zorder=0)
        plt.arrow(
            1.15, 0.5, dx=-0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:topaz"
        )

    if wm_flag[5]:  # B0
        plt.plot([0.1, 0.9], [1.25, 1.25], color="xkcd:orange", zorder=0)
        plt.arrow(
            0.67, 1.25, dx=-0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:orange"
        )

    if wm_flag[6]:  # B1
        plt.plot([1.1, 1.9], [0.75, 0.75], color="xkcd:orange", zorder=0)
        plt.arrow(
            1.67, 0.75, dx=-0.1, dy=0.0, width=0.0, head_width=0.1, color="xkcd:orange"
        )

    plt.ylim([0.25, 1.75])
    plt.axis("off")

    if color:
        for line in ax.get_lines():
            line.set_color(color)

        for patch in ax.patches:
            patch.set_facecolor(color)
            patch.set_edgecolor(color)

        for path_collection in ax.collections:
            path_collection.set_facecolor(color)
            path_collection.set_edgecolor(color)


def plot_dqn_weight_matrix(n_input_units, n_hidden_units, n_output_units, wm_flag):
    """ """
    cmap = colors.ListedColormap(
        ["white", "xkcd:slate grey", "xkcd:teal blue", "xkcd:topaz", "xkcd:orange"]
    )

    ni = n_input_units
    nh = n_input_units + n_hidden_units
    no = n_input_units + n_hidden_units + n_output_units

    w = np.zeros((no, no))

    w[:ni, ni:nh] = 1  # ih
    w[ni:nh, nh:no] = 1  # ho

    if wm_flag[0]:  # ii
        w[:ni, :ni] = 2
    if wm_flag[1]:  # hh
        w[ni:nh, ni:nh] = 2
    if wm_flag[2]:  ## oo
        w[nh:, nh:] = 2
    if wm_flag[3]:  # io
        w[:ni, nh:] = 3
    if wm_flag[4]:  # oi
        w[nh:, :ni] = 3
    if wm_flag[5]:  # hi
        w[ni:nh, :ni] = 4
    if wm_flag[6]:  # oh
        w[nh:, ni:nh] = 4

    plt.imshow(w, cmap=cmap, vmin=0, vmax=4)


def plot_dqn_rankings(y, y_label, interest, i_cols, y_lim=None, sig_test=False):
    """
    Plot each architecture's distribution for a given metric.
        Sorted by their median value.
    Arguments:
        y: metric - architectures x repeats.
        y_label: y axis label.
        interest: a list of architectures to highlight.
        i_cols: a list of colors for the architectures of interest.
        y_lim: y axis limits.
        sig_test: if an architecture label (an int) is provided.
            Test for significant differences between label and all other architectures.
            Uses Mann-Whitney U, with correction for multiple comparions.
    """

    idxs = np.argsort(np.nanmedian(y, axis=1))

    fig, ax = plt.subplots(
        nrows=1, ncols=y.shape[0], figsize=(30, 5), sharex=True, sharey=True
    )

    for a, i in enumerate(idxs):
        plt.sca(ax[a])

        if i in interest:
            sns.violinplot(
                x=np.zeros(y.shape[1]),
                y=y[i],
                color=i_cols[np.where(interest == i)[0][0]],
                linewidth=0,
                inner=None,
                cut=0,
            )
        else:
            sns.violinplot(
                x=np.zeros(y.shape[1]),
                y=y[i],
                color="xkcd:grey",
                linewidth=0,
                inner=None,
                cut=0,
            )

        ax[a].set_xticks([])
        ax[a].spines["bottom"].set_visible(False)

        if a == 0:
            plt.ylabel(y_label)
            if y_lim:
                plt.ylim(y_lim)
        else:
            ax[a].spines["left"].set_visible(False)
            ax[a].tick_params(left=False, bottom=False)

    # Significance testing
    if sig_test:
        from scipy import stats

        ps = []
        for a, i in enumerate(idxs):
            _, p = stats.mannwhitneyu(
                x=y[sig_test], y=y[i], method="asymptotic", nan_policy="omit"
            )
            ps.append(p)

        # Multiple comparions adjustment
        ps = np.array(ps)
        ps = stats.false_discovery_control(ps)
        print(str(np.sum(ps < 0.05)) + " significantly different")

        for a, i in enumerate(idxs):
            if ps[a] < 0.05:
                plt.sca(ax[a])
                plt.scatter(
                    x=0,
                    y=max(y.reshape(-1)) + (0.1 * max(y.reshape(-1))),
                    c=i_cols[np.where(np.array(interest) == sig_test)[0][0]],
                    marker="$*$",
                )


def plot_dqn_examples(y, y_label, interest, i_cols, y_lim=None, sig_test=False):
    """
    Plot the overall distribution for a given metric,
        And the distributions for the architectures in interest.
    Arguments:
        y: metric - architectures x repeats.
        y_label: y axis label.
        interest: a list of architectures to highlight.
        i_cols: a list of colors for the interest architectures.
        y_lim: y axis limits.
        sig_test: if an architecture label (an int) is provided.
            Test for significant differences between label and the architectures in interest.
            Uses Mann-Whitney U.
    """

    import warnings

    warnings.filterwarnings("ignore", module="seaborn")

    fig, ax = plt.subplots(
        nrows=1, ncols=len(interest) + 1, figsize=(5, 5), sharex=False, sharey=True
    )

    # Overall distribution
    plt.sca(ax[0])
    sns.violinplot(y.reshape(-1), color="w", linewidth=3, inner=None, cut=0)
    ax[0].set_xticks([])
    ax[0].spines["bottom"].set_visible(False)
    plt.ylabel(y_label)
    if y_lim:
        plt.ylim(y_lim)

    # Architectures of interest
    for a, i in enumerate(interest):
        plt.sca(ax[a + 1])
        sns.swarmplot(y[i], color=i_cols[a])
        plt.axis("off")

    # Significance testing
    if sig_test:
        from scipy.stats import mannwhitneyu

        for a, i in enumerate(interest):
            _, p = mannwhitneyu(
                x=y[sig_test], y=y[i], method="asymptotic", nan_policy="omit"
            )
            if p < 0.05:
                plt.sca(ax[a + 1])
                plt.scatter(
                    x=0,
                    y=max(y.reshape(-1)) + (0.1 * max(y.reshape(-1))),
                    c=i_cols[np.where(np.array(interest) == sig_test)[0][0]],
                    marker="$*$",
                )
